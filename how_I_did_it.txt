Primero desensamble la bomba en un .txt para poder mirar el codigo, y con Ctrl+F fui yendo a las fases

[Phase 1]
Mire el codigo de la Fase 1 y vi que llamaba un strings_not_equal
Pero antes de llamar a la funcion con el string correcto cargado, dejaba con un comentario arriba 
En el comentario mostraba cual era la direccion del string guardado en rsi (0x4c9a58)
Asi que simplemente puse un breakpoint en phase_1, y cuando llegue al breakpoint, corri:
x/s 0x4c9a58
para obtener el string, y obtuve "Cada uno es como Dios le hizo, y aun peor muchas veces."


[Phase 2]
BUsco phase_2 en el assembly.txt, encuentro 
Veo que guarda tres valores, con cada (call 406890 <__strtol>) y subsecuente mov 
En los movs de abajo guarda rbp, rbx & eax. Estos siendo mis 3 inputs, que puedo tomar como numeros enteros.
rbp = a, rbx = b, eax = c. 

401e94 hace xor ebx,ebp
Lo cual hace el xor entre (a, b), con ebx y ebp siendo sus versiones de 32 bits para poder hacer el xor, dando (a ^ b)
Luego del XOR hace un shift right (sar ebx,1), por lo cual el resultado pasa a ser ((a ^ b) >> 1)
Luego hace un compare en 'cmp ebx,eax', comparando el valor  

401e9a hace 'jne 401eb7 <phase_2+0x95>', un "jump if not equal", 
Entonces si no dieron iguales, salta directamente a la instruccion 401eb7, que es indeed, explode_bomb
Mientras que si dieron iguales, sigue con la logica, haciendo 'mov edi,r12d'. Por lo cual ((a ^ b) >> 1) tiene que ser igual a c
Y luego pasando a 'call 401e0b <misterio>'.

<misterio> esta definida arriba, y dentro de ella se ve un (test edi,edi) que setea su flag de signo al llamarlas (un and entre dos 
variables iguales no va a hacer nada realmente, es como un AND que no modifica nada mas, usado para tener las flags para la linea siguiente). 
Y despues viene la linea realmente importante aca, que es 'js 401e21 <misterio+0x16>'
Es decir, Jump if Sign, tal que si tiene signo negativo, salta a 401e21 (ret de misterio, pasamos de forma segura)
Y si el signo no es negativo, sigue con las lineas de <misterio>, encontrando un <explode_bomb> inmediatamente.
Entonces, sabemos que el valor edi que ingrese a misterio debe ser negativo para que no explote.

Recordemos que antes de pasar a misterio se corrio un 'mov edi,r12d', y si chequeamos mas arriba, r12d guardaba el valor de eax
En la linea 'mov r12d,eax' que se inmediatamente abajo del tercer strtol. Por lo cual, la variable de input que debe ser negativa.
Entonces, ya tenemos todas nuestras condiciones :)

Hay 3 integers de inputs (que llamamos a, b, c), y sabemos que tienen que cumplir:
- ((a ^ b) >> 1) == c
- c < 0

Hay varias combinaciones de 3 digitos que cumplen esto, una de ellas siendo por ejemplo:
a = -2
b = 1
c = -1



[Phase 3]
suma de indices ._.
(busqueda binaria de la palabra, y va sumando los indices por los que pasa)
mid_word, mid_index
one_fourth_word, mid_index + one_fourth_index
one_eighth_word, mid_index + one_fourth_index + one_eighth_index
etc.

